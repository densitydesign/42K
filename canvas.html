<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
body {
    background-color: black;
    margin: 0;
    padding: 0;
}

svg {
    /*    width: 1024px;
    height: 768px;*/
}

canvas {
    /*background-color: red;*/
}

.node {
    stroke: none;
    fill: white;
}
</style>
<!-- <svg></svg> -->
<canvas></canvas>
<script src="https://d3js.org/d3.v4.min.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/npm/hidpi-canvas@1.0.10/dist/hidpi-canvas.min.js"></script> -->
<script>
var width = window.innerWidth,
    height = window.innerHeight,
    svg = d3.select("svg").attr('width', width).attr('height', height),
    canvas = document.querySelector("canvas"),
    context = canvas.getContext("2d"),
    nodeRadius = 1;

d3.select(canvas)
    .attr('width', width*2)
    .style('width', width + 'px')
    .attr('height', height*2)
    .style('height', height + 'px')

context.scale(2,2);

var nodes = [];

function addNodes(n) {
    for (var i = 0; i < n; i++) {
        var myX = Math.random() * width;
        var myY = Math.random() * height;

        var random = Math.random();

        var role;

        if (random > 0.07) {
            role = 'studente';
        } else {
            role = 'prof';
        }

        nodes.push({ 'id': i, 'r': nodeRadius, 'x': myX, 'y': myY, 'role': role });
    }
}

function removeNodes(n) {
    for (var i = nodes.length; i > nodes.length - n; i++) {
        if (nodes.length > 0) {
            var randomIndex = Math.floor(nodes.length * Math.random)
            nodes.splice(randomIndex, 1)
        }
    }
}

addNodes(45000)

nodes.forEach(function(d) {
    var myX = Math.random() * width;
    var myY = Math.random() * height;

    d.x = myX;
    d.y = myY;
})

var forceX = d3.forceX(function(d) {
    if (d.role == 'studente') {
        return width / 4;
        // return 400
    } else {
        // return width / 4 * 3;
        return width - 150;
    }
}).strength(0.05);

var forceY = d3.forceY(height / 2).strength(0.05);

var charge = d3.forceManyBody().strength(-0.25);

var collide = d3.forceCollide(function(d) { return d.r + 1 })

var simulation = d3.forceSimulation(nodes)
    // .force('center', d3.forceCenter(width/2, height/2))
    .force("collide", null)
    .force('x', null)
    .force('y', null)
    .force('charge', null)
    .alpha(1)
    // .alphaMin(0.4)
    .alphaDecay(0.000)
    .on("tick", ticked)


var g = svg.append("g"),
    node = svg.selectAll(".node");

// update();

function update() {
    var beginTime = d3.now();

    function drawGraph() {
        // Apply the general update pattern to the nodes.
        node = node.data(nodes, function(d) { return d.id; });
        node.exit().remove();
        node = node.enter().append("circle")
            .attr('class', 'node')
            .merge(node)
            .attr("r", function(d) { return d.r; })
            .attr('cx', function(d) { return d.x; })
            .attr('cy', function(d) { return d.y; })
    }

    drawGraph();

    // Update and restart the simulation.
    simulation.nodes(nodes);
    simulation.alpha(1).restart();
    simulation.on("end", function() {
        console.log('calc done', d3.now() - beginTime);
        // console.log(JSON.stringify(nodes, null, 2));

    })
}

function ticked() {
    context.clearRect(0, 0, width, height);
    context.save();
    // context.translate(width / 2, height / 2 + 40);

    // context.beginPath();
    // graph.links.forEach(drawLink);
    // context.strokeStyle = "#aaa";
    // context.stroke();

    context.beginPath();
    nodes.forEach(drawNode);
    context.fillStyle = '#fff';
    context.fill();
    // context.strokeStyle = "#fff";
    // context.stroke();

    context.restore();
    // console.log('tick')
}

function drawNode(d) {
    context.moveTo(d.x + d.r, d.y);
    context.arc(d.x, d.y, d.r, 0, 2 * Math.PI);
}


// d3.timeout(function() {
//     console.log('collide');

//     simulation
//         .force("collide", collide)
//     update();

// }, 1000, d3.now());

d3.timeout(function() {
    console.log('split');

    simulation
        .force("x", forceX)
        .force('y', forceY)
        .force('charge', charge)
        // .force('collide', collide);

    update();
}, 1000, d3.now());
</script>