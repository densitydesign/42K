<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" type="text/css" href="style.css">
<canvas></canvas>
<script src="https://d3js.org/d3.v4.min.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/npm/hidpi-canvas@1.0.10/dist/hidpi-canvas.min.js"></script> -->
<script>
//spazio per interfaccia a lato SX 850px, circa il 22%

var width = window.innerWidth,
  height = window.innerHeight,
  svg = d3.select("svg").attr('width', width).attr('height', height),
  canvas = document.querySelector("canvas"),
  context = canvas.getContext("2d"),
  nodeRadius = 1,
  nodes = [];

d3.select(canvas)
  .attr('width', width * 2)
  .style('width', width + 'px')
  .attr('height', height * 2)
  .style('height', height + 'px')

context.scale(2, 2);

d3.tsv('./assets/data/dati-studenti-professori.tsv', function(err, data) {
  if (err) {
    throw err;
  }
  // console.log(data);

  data.forEach(function(d) {
    var myX = width * 0.22 + width * 0.78 * Math.random();
    var myY = Math.random() * height;
    d.x = myX;
    d.y = myY;
    d.r = 1;
  })
  console.log(data);
  nodes = data;

  var tempData = [];
  for (var i = 0; i < data.length; i += 10) {
    tempData.push(data[i]);
  }
  nodes = tempData;


})

var collide = d3.forceCollide(function(d) { return d.r + 1 })

var simulation = d3.forceSimulation(nodes)
  // .force('center', d3.forceCenter(width/2, height/2))
  .force("collide", null)
  .force('x', null)
  .force('y', null)
  .force('charge', null)
  .alpha(1)
  .alphaMin(0.1)
  .alphaDecay(0.01)
  .on("tick", function() {
    ticked(nodes)
  })
  // .on("tick", null)
  .on("end", function() {
    console.log('calc done');
  })

d3.select('body').append('div')
  .attr('class', 'ui-box')
  .append('p')
  .attr('id', 'force-restart')
  .html('restart simulation')
  .on('click', function() {
    simulation.alpha(1).restart();
  })

function tipologie(theSimulation) {
  console.log('nodi separati per studenti, professori');
  var forceX = d3.forceX(function(d) {
    if (d['Tipo'] == 'studente') {
      return width * 0.22 + 450;
    } else {
      return width - 135 - 200;
    }
  }).strength(0.05);

  var forceY = d3.forceY(height / 2).strength(0.05);

  var charge = d3.forceManyBody().strength(-0.2);

  theSimulation
    .force("collide", null)
    .force('x', forceX)
    .force('y', forceY)
    .force('charge', charge)
    .on("tick", function() {
      ticked(nodes);
    })

  update(nodes);
}
d3.select('.ui-box')
  .append('p')
  .html('separati per tipologia')
  .on('click', function() {
    tipologie(simulation);
  })

function soloStudenti(theSimulation) {
  console.log('solo studenti al centro');

  var forceX = d3.forceX(width * 0.22 + (width * 0.78) / 2).strength(0.05);
  var forceY = d3.forceY(height / 2).strength(0.05);
  var charge = d3.forceManyBody().strength(-0.2);

  var thisData = nodes.filter(function(d) {
    return d['Tipo'] == 'studente'
  })

  theSimulation
    .force("collide", null)
    .force('x', forceX)
    .force('y', forceY)
    .force('charge', charge)
    .on("tick", function() {
      ticked(thisData);
    })

  update(thisData);
}
d3.select('.ui-box')
  .append('p')
  .html('solo studenti al centro')
  .on('click', function() {
    soloStudenti(simulation);
  })

function livelli(theSimulation) {
  console.log('solo studenti divisi per livelli T M');

  var forceX = d3.forceX(function(d) {
    if (d['Livello'] == 'T') {
      return width * 0.22 + 360;
    } else {
      return width - 290;
    }
  }).strength(0.05);
  var forceY = d3.forceY(height / 2).strength(0.05);
  var charge = d3.forceManyBody().strength(-0.2);

  var thisData = nodes.filter(function(d) {
    return d['Tipo'] == 'studente'
  })

  theSimulation
    .force("collide", null)
    .force('x', forceX)
    .force('y', forceY)
    .force('charge', charge)
    .on("tick", function() {
      ticked(thisData);
    })

  update(thisData);
}
d3.select('.ui-box')
  .append('p')
  .html('Triennale Magistrale')
  .on('click', function() {
    livelli(simulation);
  })

function scuole(theSimulation) {
  console.log('studenti divisione per scuole:\nIng Ind - Inf, Ing - Civ, Arc - Urb - Cost, Des');
  var forceX = d3.forceX(function(d) {
    if (d['Scuola'] == 'Ing Ind - Inf') {
      return width * 0.22 + (width * 0.78) / 5;
    } else if (d['Scuola'] == 'Ing - Civ') {
      return width * 0.22 + (width * 0.78) / 5 * 2;
    } else if (d['Scuola'] == 'Arc - Urb - Cost') {
      return width * 0.22 + (width * 0.78) / 5 * 3;
    } else if (d['Scuola'] == 'Des') {
      return width * 0.22 + (width * 0.78) / 5 * 4;
    } else {
      return width
    }
  }).strength(0.05);


  var forceY = d3.forceY(height / 2).strength(0.05);
  var charge = d3.forceManyBody().strength(-0.2);

  var thisData = nodes.filter(function(d) {
    return d['Tipo'] == 'studente'
  })

  theSimulation
    .force("collide", null)
    .force('x', forceX)
    .force('y', forceY)
    .force('charge', charge)
    .on("tick", function() {
      ticked(thisData);
    })

  update(thisData);
}
d3.select('.ui-box')
  .append('p')
  .html('Scuole')
  .on('click', function() {
    scuole(simulation);
  })

function cittadinanza(theSimulation) {
  console.log('studenti divisi per cittadinanza');
  var thisData = nodes.filter(function(d) {
    return d['Tipo'] == 'studente';
  })

  var entries = d3.nest()
    .key(function(d) { return d['Cittadinanza']; })
    .rollup(function(d) { return d.length; })
    .entries(thisData);
  
  entries = entries.sort(function(a,b){
    return b.value - a.value;
  })
  console.log(entries.length)

  var rowIndex = [0,0];
  var rowVertical;
  var rowHorizontal = 0;
  entries.forEach(function(d,i){
    var r = Math.sqrt(d.value*12/Math.PI);
    var margin = 30;
    d.r = r + margin;
    d.x = 0 + rowHorizontal;
    for (var j=0; j<i; j++){
      // console.log(entries[j].r);
      d.x += entries[j].r*2;
    }
    if (!rowVertical) {
      rowVertical = d.r;
    }
    d.y = rowVertical;
    d.x += r;

    if(d.x > width*0.78){
      rowIndex[0]++;
      console.log('out', rowIndex, entries[i]);
      rowVertical += rowVertical + d.r;
      rowHorizontal -= d.x;
      entries[i].x += rowHorizontal;
      entries[i].y = rowVertical;
    //   d.x += rowHorizontal + 15 + d.r;
    //   d.y = rowVertical;
    }
    rowIndex[1]++;
    // console.log(d);
  })



  var forceX = d3.forceX(function(d) {
    var xposition = width;
    entries.forEach(function(c,i) {
      if (c.key == d['Cittadinanza']) {
        xposition = width * 0.22 + c.x;   
      }
    })
    return xposition;
  }).strength(0.05);


  var forceY = d3.forceY(function(d){
    var yposition = height/2;
    entries.forEach(function(c,i) {
      if (c.key == d['Cittadinanza']) {
        yposition = c.y;   
      }
    })
    return yposition
  }).strength(0.05);
  var charge = d3.forceManyBody().strength(-0.2);

  theSimulation
    .force("collide", null)
    .force('x', forceX)
    .force('y', forceY)
    .force('charge', charge)
    .on("tick", function() {
      ticked(thisData);
    })

  update(thisData);
}
d3.select('.ui-box')
  .append('p')
  .html('Cittadinanza')
  .on('click', function() {
    cittadinanza(simulation);
  })


var g = svg.append("g"),
  node = svg.selectAll(".node");

// update();

function update(dataNodes) {
  var beginTime = d3.now();

  function drawGraph() {
    // Apply the general update pattern to the nodes.
    node = node.data(dataNodes, function(d) { return d['ID']; });
    node.exit().remove();
    node = node.enter().merge(node)
  }
  // drawGraph();

  // Update and restart the simulation.
  simulation
    .nodes(dataNodes)
    .alpha(1)
    .restart();
}

function ticked(nodes) {
  context.clearRect(0, 0, width, height);
  // context.save();
  // context.translate(width / 2, height / 2 + 40);

  // context.beginPath();
  // graph.links.forEach(drawLink);
  // context.strokeStyle = "#aaa";
  // context.stroke();

  context.beginPath();
  nodes.forEach(drawNode);
  context.fillStyle = '#fff';
  context.fill();
  // context.strokeStyle = "#fff";
  // context.stroke();

  // context.restore();
  // console.log('tick')
}

function drawNode(d) {
  context.moveTo(d.x + d.r, d.y);
  context.arc(d.x, d.y, d.r, 0, 2 * Math.PI);
}

</script>
