<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" type="text/css" href="style.css">
<canvas></canvas>
<div class="ui-box"></div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/npm/hidpi-canvas@1.0.10/dist/hidpi-canvas.min.js"></script> -->
<script>
//spazio per interfaccia a lato SX 850px, circa il 22%

var width = window.innerWidth,
    height = window.innerHeight,
    svg = d3.select("svg").attr('width', width).attr('height', height),
    canvas = document.querySelector("canvas"),
    context = canvas.getContext("2d"),
    nodeRadius = 1,
    nodes = [];

d3.select(canvas)
    .attr('width', width * 2)
    .style('width', width + 'px')
    .attr('height', height * 2)
    .style('height', height + 'px')

context.scale(2, 2);

var simulation = d3.forceSimulation(nodes)
    // .force('center', d3.forceCenter(width/2, height/2))
    .force("collide", null)
    .force('x', null)
    .force('y', null)
    .force('charge', null)
    .alpha(1)
    .alphaMin(0.3)
    .alphaDecay(0.01)
    .on("tick", null)
    .on("tick", null)
    .on("end", function() {
        console.log('calc done');
    })

d3.select('.ui-box')
    .append('p')
    .attr('id', 'force-restart')
    .html('restart simulation')
    .on('click', function() {
        simulation.alpha(1).restart();
    })

d3.select('.ui-box')
    .append('p')
    .attr('id', 'force-stop')
    .html('stop simulation')
    .on('click', function() {
        simulation.stop();
    })

d3.select('.ui-box')
    .append('div')
    .attr('id', 'alpha-meter')

function ticked(data, cittadinanze) {
    context.clearRect(0, 0, width, height);
    context.save();

    context.beginPath();
    data.forEach(drawNode);
    context.fillStyle = '#fff';
    context.fill();

    // if (cittadinanze) {
    //     if (simulation.alpha() <= 0.8) {
    //         context.font = "9px Open Sans";
    //         context.textAlign = "center";
    //         context.fillStyle = '#fff';
    //         cittadinanze.forEach(function(ccc) {
    //             var thesePoints = nodes.filter(function(n) {
    //                 return n['Cittadinanza'] == ccc.key;
    //             })
    //             thesePoints = thesePoints.map(function(d) {
    //                 return [d.x, d.y]
    //             })
    //             // console.log(thesePoints)
    //             if (thesePoints.length > 2) {
    //                 var thisHull = d3.polygonHull(thesePoints);
    //                 var thisCentroid = d3.polygonCentroid(thisHull);

    //                 context.fillStyle = "rgba(255,255,255,00)";
    //                 var tw = context.measureText(ccc.key).width + 4;

    //                 var tx = thisCentroid[0];
    //                 var ty = thisCentroid[1] + ccc.r + 20;

    //                 context.fillRect(tx - tw / 2, ty - 9, tw, 12);
    //                 context.fillStyle = "#fff";
    //                 context.fillText(ccc.key, tx, ty);
    //             } else {
    //                 context.fillStyle = "rgba(255,255,255,00)";
    //                 var tw = context.measureText(ccc.key).width + 4;

    //                 var tx = thesePoints[0][0];
    //                 var ty = thesePoints[0][1] + ccc.r + 15;

    //                 context.fillRect(tx - tw / 2, ty - 9, tw, 12);


    //                 context.fillStyle = "#fff";
    //                 context.fillText(ccc.key, tx, ty);
    //             }
    //             // context.beginPath();
    //             // context.strokeStyle = '#fff';
    //             // // context.moveTo(ccc.x + ccc.r, ccc.y);
    //             // context.arc(ccc.x, ccc.y, ccc.r, 0, 2 * Math.PI);
    //             // context.stroke();

    //         })
    //     }
    // }

    context.restore();
    // console.log('tick')
    d3.select('#alpha-meter').style('width', 100 * simulation.alpha() + '%')
}

function drawNode(d) {
    context.moveTo(d.x + d.r, d.y);
    context.arc(d.x, d.y, d.r, 0, 2 * Math.PI);
}

function calcLayout(data, type, clusters, filter, facet, size) {

    console.log(data.length + ' points')

    switch (type) {
        case 'flock':
            console.log('Selected floking layout on ' + clusters + ' with a filter on ' + JSON.stringify(filter));

            if (filter.property) {
                console.log('Data filtered by:', filter)
                data = data.filter(function(d) {
                    return d[filter.property] == filter.value
                })
            } else {
                console.log('Data not filtered')
            }

            console.log(data.length + ' points')

            var thisGroups = d3.nest()
                .key(function(d) { return d[clusters]; })
                .rollup(function(d) { return d.length; })
                .entries(data);
            thisGroups.forEach(function(d, i) {
                d.x = size.left + ((width - size.left) / (thisGroups.length + 1) * (i + 1));
                d.y = height / 2;
            })
            console.log('Found clusters on property', clusters + ': ', thisGroups);

            data.forEach(function(d) {
                d.cluster_x = thisGroups.find(function(e) {
                    return e.key == d[clusters]
                }).x
                d.cluster_y = thisGroups.find(function(e) {
                    return e.key == d[clusters]
                }).y
            })

            var forceX = d3.forceX(function(d) {
                return d.cluster_x
            })

            var forceY = d3.forceY(function(d) {
                return d.cluster_y
            })

            var repulsion = d3.forceManyBody().strength(-0.3).theta(1.6);
            simulation
                .nodes(data)
                .force('x', forceX)
                .force('y', forceY)
                .force('charge', repulsion)
                .on("tick", function() {
                    ticked(data);
                    if (simulation.alpha() <= .8) {
                        simulation
                            .force('charge', repulsion.theta(0.9))
                    }
                })
                .alpha(1)
                .alphaDecay(0.01)
                .restart();
            break;
        case 'grid':
            console.log('grid layout');
            break;
        default:
            console.log('switch to default');
            simulation
                .nodes(data)
                .force('x', null)
                .force('y', null)
                .force('charge', null)
                .on("tick", function() {
                    ticked(data);
                })
                .alpha(1)
                .alphaDecay(0.01)
                .restart();
            break;
    }

}

function cittadinanza(theSimulation) {
    console.log('studenti divisi per cittadinanza');
    var thisData = nodes.filter(function(d) {
        return d['Tipo'] == 'studente';
    })

    var countries = d3.nest()
        .key(function(d) { return d['Cittadinanza']; })
        .rollup(function(d) { return d.length; })
        .entries(thisData);

    countries = countries.sort(function(a, b) {
        return b.value - a.value;
    })

    var cut = { floor: 0, ceil: 120 }

    countries = countries.slice(cut.floor, cut.ceil);

    thisData = thisData.filter(function(d) {
        var flag = false;
        countries.forEach(function(e) {
            if (e.key == d['Cittadinanza']) {
                flag = true;
            }
        })
        return flag
    })

    // console.log(countries);

    // positioning the citizenships according to their quantity
    var size = {
        top: 0,
        bottom: height,
        left: width * 0.3,
        right: width * 0.9
    }

    var row = {
        number: 0,
        y: undefined,
        maxradius: undefined,
        margin: 60
    }
    countries.forEach(function(d, i) {
        var margin = row.margin;

        d.r = Math.sqrt(d.value / Math.PI) * 3.2;

        d.x = d.r + margin;
        if (i == 0) {
            d.x += size.left + margin * 0
            row.maxradius = d.r * 0.35;
        } else if (i > 0) {
            d.x += countries[i - 1].x + countries[i - 1].r;
        }

        // console.log(d.x, size.right, d.x > size.right)
        var k = Math.floor((d.x / size.right))

        if (!row.y) {
            row.y = d.r + margin * 0;
            // row.y = d.r/2;
        }

        if (k == 1) {
            d.x -= countries[i - 1].x + countries[i - 1].r;
            d.x += size.left;

            row.y = countries[i - 1].y + row.maxradius + d.r + margin * 0.65;

            row.maxradius = d.r;
        }
        d.y = row.y;
        // console.log(d.x)
    })

    console.log(countries);



    var forceX = d3.forceX(function(d) {
        var xposition = width;
        countries.forEach(function(c, i) {
            if (c.key == d['Cittadinanza']) {
                xposition = c.x;
                // if (c.key == 'ITALIANA') {
                //   xposition -= row.margin*3
                // }
            }
        })
        return xposition;
    })
    forceX.strength(0.1);


    var forceY = d3.forceY(function(d) {
        var yposition = height / 2;
        countries.forEach(function(c, i) {
            if (c.key == d['Cittadinanza']) {
                yposition = c.y;
                // if (c.key == 'ITALIANA') {
                //   yposition -= row.margin*3
                // }
            }
        })
        return yposition
    })
    forceY.strength(0.1);


    var charge = d3.forceManyBody()

    charge
        .strength(-0.3)
        .theta(1.5)

    var collide = d3.forceCollide(function(d) { return d.r + 1 }).strength(1.3).iterations(2)

    theSimulation
        .force('x', forceX)
        .force('y', forceY)
        .force('charge', charge)
        .on("tick", function() {
            ticked(thisData, countries);
            if (theSimulation.alpha() <= .85) {
                theSimulation
                    .force('charge', charge.theta(.9))
            }
        })

    update(thisData);
}


var g = svg.append("g"),
    node = svg.selectAll(".node");

d3.tsv('./assets/data/dati-studenti-professori.tsv', function(err, data) {
    if (err) {
        throw err;
    }
    // console.log(data);

    data.forEach(function(d) {
        var myX = width * 0.22 + width * 0.78 * Math.random();
        myX = width * Math.random();
        var myY = Math.random() * height;
        d.x = myX;
        d.y = myY;
        d.r = 1;
    })
    // console.log(data);
    nodes = data;

    // filter the data so to have less things to display and improve performances
    var tempData = [];
    for (var i = 0; i < data.length; i += 1) {
        tempData.push(data[i]);
    }
    nodes = tempData;

    // run the layout to place points randomly
    calcLayout(nodes, null, null, null, null, null);

    var size = {
        top: 0,
        bottom: height,
        left: width * 0.22,
        right: width * 1,
        height: height,
        width: width
    }
    var onlyStudents = { property: 'Tipo', value: 'studente' }

    var facet;

    d3.select('.ui-box')
        .append('p')
        .html('Flock per Tipo no filtri no facet')
        .on('click', function() {
            calcLayout(nodes, 'flock', 'Tipo', {}, undefined, size);
            console.log('all data ' + nodes.length + ' tipo');
            console.log('---------------------');
        })

    d3.select('.ui-box')
        .append('p')
        .html('Flock per Livello solo studenti no facet')
        .on('click', function() {
            calcLayout(nodes, 'flock', 'Livello', onlyStudents, undefined, size);
            console.log('all data ' + nodes.length + ' tipo');
            console.log('---------------------');
        })

    d3.select('.ui-box')
        .append('p')
        .html('Flock per Scuola solo studenti no facet')
        .on('click', function() {
            calcLayout(nodes, 'flock', 'Scuola', onlyStudents, undefined, size);
            console.log('all data ' + nodes.length + ' scuola');
            console.log('---------------------');
        })

    d3.select('.ui-box')
        .append('p')
        .html('Flock per Cittadinanza solo studenti no facet')
        .on('click', function() {
            calcLayout(nodes, 'flock', 'Cittadinanza', onlyStudents, undefined, size);
            console.log('all data ' + nodes.length + ' scuola');
            console.log('---------------------');
        })


})
</script>