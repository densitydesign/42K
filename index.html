<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<style>
body {
    background-color: black;
    margin: 0;
    padding: 0;
}

svg {
/*    width: 1024px;
    height: 768px;*/
}

.node {
    stroke: none;
    fill: white;
}
</style>
<svg></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
var width = window.innerWidth,
    height = window.innerHeight,
    svg = d3.select("svg").attr('width', width).attr('height', height),
    nodeRadius = 1;

var nodes = [];

function addNodes(n) {
    for (var i = 0; i < n; i++) {
        var myX = Math.random() * width;
        var myY = Math.random() * height;
        nodes.push({ 'id': i, 'r': nodeRadius, 'x': myX, 'y': myY });
    }
}

function removeNodes(n) {
    for (var i = nodes.length; i > nodes.length - n; i++) {
        if (nodes.length > 0) {
            var randomIndex = Math.floor(nodes.length * Math.random)
            nodes.splice(randomIndex, 1)
        }
    }
}

addNodes(42000);



var simulation = d3.forceSimulation(nodes)
    .force("collide", d3.forceCollide(function(d) { return d.r + 1 }).strength(3))
    .alpha(1)
    .alphaDecay(0.01)
    .on("tick", ticked)


var g = svg.append("g"),
    node = svg.selectAll(".node");

update();

function update() {
    var beginTime = d3.now();

    function drawGraph() {
        // Apply the general update pattern to the nodes.
        node = node.data(nodes, function(d) { return d.id; });
        node.exit().remove();
        node = node.enter().append("circle")
            .attr('class', 'node')
            .merge(node)
            .attr('cx', function(d) { return d.x; })
            .attr('cy', function(d) { return d.y; })
            .attr("r", function(d) { return d.r; });
    }

    drawGraph();

    // Update and restart the simulation.
    simulation.nodes(nodes);
    simulation.alpha(1).restart();
    simulation.on("end", function() {
        console.log('calc done', d3.now() - beginTime);

    })
}

function ticked() {

    // ordinary tick function for force layout
    // node.attr("cx", function(d) { return d.x; })
    //     .attr("cy", function(d) { return d.y; })

    // Bounded force layout (https://bl.ocks.org/mbostock/1129492)
    // Math.max( nodeRadius, Math.min(width - nodeRadius, d.x) )
    // the function above is useful for returning nodes positions within the svg and not outside of it.
    node.attr("cx", function(d) { return d.x = Math.max(nodeRadius, Math.min(width - nodeRadius, d.x)); })
        .attr("cy", function(d) { return d.y = Math.max(nodeRadius, Math.min(height - nodeRadius, d.y)); })
}
</script>